---
layout: post
title: "7. A*, Weighted A*, Backward A*"
mathjax: true
comments: true
description: "Turtlebot3"
keywords: "Turtlebot3"
---  

### 7.1 Recall!
From the previous post, we learned that $$f(n) = h(n)$$ search becomes **greedy** and $$f(n) = g(n)$$ search grows path that is shortest from start until it encounters the goal(**Dijkstra's algorithm or Uninformed A\***). Now, the A\* algorithm is just the combination of both.
<p align="center">
  $$f(n) = h(n) + g(n) \tag{1}$$
</p>
Now, lets take a deeper dive in the algorithm.

### 7.2 A\* Algorithm
I bet you remember all the terminologies.  

![star]({{ site.url }}/assets/images/a_starr.PNG)  

Now, take a pen and a scratch paper and try to understand the algorithm by solving the following example.    

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ![eg]({{ site.url }}/assets/images/example_astarr.png)

<p align="center">
Figure 7.1 Example
</p>

Here, assume the function $h(s)$ gives the number of nodes $s$ is away from $s_{goal}$.  

Node To Expand | OPEN | CLOSED | bp(s)
--- | --- | ---
$s_{start}$ | {$s_{start}$} | {} | \-
$s_2$ | $s_2$ | {$s_{start}$} | $bp(s_2) = s_{start}$
$s_4$ | {$s_4, s_1$} | {$s_{start}, s_2$} | $bp(s_4) = bp(s_1) = s_2$ 
$s_1$ | {$s_3, s_1$} | {$s_{start}, s_2, s_4$} | $bp(s_3) = s_4$
$s_{goal}$ | {$s_3, s_{goal}$} | {$s_{start}, s_2, s_4, s_1$} | $bp(s_{goal}) = s_1$
\- | {$s_3$} | {$s_{start}, s_2, s_4, s_1, s_{goal}$} | \-

Finally, in order to find the path we have to just follow the backpointers all the way from $s_goal$ to $s_start$.

  

